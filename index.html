<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hot Potato Game</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background-color: #ffe6f0;
    margin: 0; padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    color: #ff4da6;
  }
  button {
    background-color: #ff80bf;
    border: none;
    padding: 10px 15px;
    margin: 5px;
    cursor: pointer;
    color: white;
    border-radius: 8px;
    font-size: 14px;
  }
  button:hover:not(:disabled) {
    background-color: #ff4da6;
  }
  button:disabled {
    background-color: #ffb3d9;
    cursor: not-allowed;
  }
  #gameArea {
    display: none;
    margin-top: 20px;
  }
  #lobbyArea {
    margin-top: 20px;
  }
  .player {
    padding: 8px 12px;
    background-color: #fff0f5;
    border: 1px solid #ffb3d9;
    border-radius: 6px;
    margin: 5px;
  }
  .player.host {
    border: 2px solid gold;
  }
  .player.out {
    opacity: 0.5;
    text-decoration: line-through;
  }
  #lyricDisplay {
    font-size: 24px;
    font-weight: bold;
    margin: 15px 0;
    color: #d6006c;
  }
  #potatoStatus, #holdTimer, #clickCountDisplay {
    margin: 5px 0;
    font-weight: bold;
  }
</style>
</head>
<body>
  <h1>Hot Potato Game</h1>

  <div id="lobbyArea">
    <input type="text" id="username" placeholder="Enter your name" />
    <button id="joinGame">Join Game</button>
    <div id="playerList"></div>
    <button id="startGame" style="display:none;">Start Game</button>
    <div id="statusMessage"></div>
  </div>

  <div id="gameArea">
    <div id="potatoStatus">Waiting...</div>
    <div>Hold Timer: <span id="holdTimer">0</span>s</div>
    <div>Clicks: <span id="clickCountDisplay">0</span></div>
    <button id="passPotato">Pass Potato (Click 5 times to pass)</button>
    <div id="lyricDisplay"></div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, arrayUnion,
  runTransaction, deleteDoc, collection, query, where, getDocs, writeBatch
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB2_jo_IniRf7IYXmdziTN4yezDxjZxTD0",
  authDomain: "hotpotatoe-12db7.firebaseapp.com",
  projectId: "hotpotatoe-12db7",
  storageBucket: "hotpotatoe-12db7.firebasestorage.app",
  messagingSenderId: "495938423140",
  appId: "1:495938423140:web:ee57563ed78bbe5f41d271",
  measurementId: "G-TRN809H4JK"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Game variables
let playerId = null;
let playerName = "";
const gameId = "main-room";
let potatoHolder = null;
const lyrics = ["hot", "potato", "hot", "potato", "hot", "potato", "hot", "potato", "if", "you", "have", "the", "Potato", "you", "are", "out!"];
let lyricIndex = 0;
const clicksToPass = 5;
const maxHoldSeconds = 5;

let lyricInterval = null;
let holdTimerInterval = null;
let holdSeconds = 0;

// DOM Elements
const usernameInput = document.getElementById("username");
const joinBtn = document.getElementById("joinGame");
const startBtn = document.getElementById("startGame");
const playerListEl = document.getElementById("playerList");
const lobbyArea = document.getElementById("lobbyArea");
const gameArea = document.getElementById("gameArea");
const potatoStatus = document.getElementById("potatoStatus");
const holdTimerDisplay = document.getElementById("holdTimer");
const clickCountDisplay = document.getElementById("clickCountDisplay");
const passBtn = document.getElementById("passPotato");
const lyricDisplay = document.getElementById("lyricDisplay");
const statusMessage = document.getElementById("statusMessage");

// Disable join button after click to prevent spam
joinBtn.addEventListener("click", async () => {
  joinBtn.disabled = true;
  playerName = usernameInput.value.trim();
  if (!playerName) {
    alert("Please enter your name.");
    joinBtn.disabled = false;
    return;
  }
  playerId = `${Date.now()}-${Math.floor(Math.random() * 1000)}`;

  const gameRef = doc(db, "games", gameId);
  const snap = await getDoc(gameRef);

  if (!snap.exists()) {
    // Create game and assign first player as host
    await setDoc(gameRef, {
      players: [{ id: playerId, name: playerName, alive: true }],
      state: "lobby",
      host: playerId,
      potatoHolder: null
    });
  } else {
    // Add player to existing lobby, prevent duplicates
    const gameData = snap.data();
    if (!gameData.players.some(p => p.id === playerId)) {
      await updateDoc(gameRef, {
        players: arrayUnion({ id: playerId, name: playerName, alive: true })
      });
    }
  }

  listenForGameUpdates();
  statusMessage.textContent = "Joined game. Waiting for host to start.";
});

// Listen to realtime game updates
function listenForGameUpdates() {
  const gameRef = doc(db, "games", gameId);
  onSnapshot(gameRef, (snap) => {
    if (!snap.exists()) return;
    const game = snap.data();

    renderPlayers(game.players, game.host);

    if (game.state === "playing") {
      lobbyArea.style.display = "none";
      gameArea.style.display = "block";

      potatoHolder = game.potatoHolder;
      lyricIndex = game.lyricIndex ?? 0;
      updatePotatoStatus();

      if (playerId === game.host) {
        startBtn.style.display = "inline-block";
      } else {
        startBtn.style.display = "none";
      }

      // Start lyric and hold timers only if host
      if (playerId === game.host && !lyricInterval) {
        startLyricTimer(gameRef);
      }
    } else {
      // Lobby state
      gameArea.style.display = "none";
      lobbyArea.style.display = "block";
      startBtn.style.display = playerId === game.host ? "inline-block" : "none";
      statusMessage.textContent = "Waiting for host to start the game.";
      clearTimers();
    }
  });
}

function renderPlayers(players, hostId) {
  playerListEl.innerHTML = "";
  players.forEach(p => {
    const div = document.createElement("div");
    div.className = "player";
    if (!p.alive) div.classList.add("out");
    if (p.id === hostId) div.classList.add("host");
    div.textContent = p.name + (p.alive ? "" : " (out)");
    playerListEl.appendChild(div);
  });
}

function updatePotatoStatus() {
  const currentHolderName = getPlayerNameById(potatoHolder);
  if (potatoHolder === playerId) {
    potatoStatus.textContent = "You have the potato!";
  } else if (currentHolderName) {
    potatoStatus.textContent = `${currentHolderName} has the potato`;
  } else {
    potatoStatus.textContent = "Waiting for potato holder...";
  }
  clickCountDisplay.textContent = currentPlayerClicks.toString();
  holdTimerDisplay.textContent = holdSeconds.toString();
}

function getPlayerNameById(id) {
  const playersDivs = playerListEl.children;
  for (let i = 0; i < playersDivs.length; i++) {
    if (playersDivs[i].textContent.startsWith(id)) {
      return playersDivs[i].textContent;
    }
  }
  return null;
}

let currentPlayerClicks = 0;

// Pass potato button click
passBtn.addEventListener("click", async () => {
  if (potatoHolder !== playerId) return;

  currentPlayerClicks++;
  clickCountDisplay.textContent = currentPlayerClicks;

  if (currentPlayerClicks >= clicksToPass) {
    // pass potato
    const gameRef = doc(db, "games", gameId);
    await runTransaction(db, async (transaction) => {
      const snap = await transaction.get(gameRef);
      if (!snap.exists()) return;
      const game = snap.data();
      const alivePlayers = game.players.filter(p => p.alive && p.id !== playerId);
      if (alivePlayers.length === 0) return; // no one to pass to
      const nextHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
      await transaction.update(gameRef, {
        potatoHolder: nextHolder,
        lyricIndex: (lyricIndex + 1) % lyrics.length,
      });
    });
    currentPlayerClicks = 0;
    holdSeconds = 0;
  }
});

function startLyricTimer(gameRef) {
  if (lyricInterval) return; // already running

  lyricInterval = setInterval(async () => {
    lyricIndex++;
    if (lyricIndex >= lyrics.length) {
      // End round - eliminate potato holder
      clearInterval(lyricInterval);
      lyricInterval = null;
      await eliminateCurrentHolderAndRestart(gameRef);
      return;
    }
    // Update lyric and reset hold timer
    holdSeconds = 0;
    await updateDoc(gameRef, { lyricIndex });
  }, 1000);

  startHoldTimer(gameRef);
}

function startHoldTimer(gameRef) {
  if (holdTimerInterval) return;

  holdTimerInterval = setInterval(async () => {
    holdSeconds++;
    holdTimerDisplay.textContent = holdSeconds;

    if (holdSeconds >= maxHoldSeconds) {
      // Auto pass potato
      clearInterval(holdTimerInterval);
      holdTimerInterval = null;
      currentPlayerClicks = 0;
      // Pass potato automatically
      await runTransaction(db, async (transaction) => {
        const snap = await transaction.get(gameRef);
        if (!snap.exists()) return;
        const game = snap.data();
        const alivePlayers = game.players.filter(p => p.alive && p.id !== game.potatoHolder);
        if (alivePlayers.length === 0) return;
        const nextHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
        await transaction.update(gameRef, {
          potatoHolder: nextHolder,
          lyricIndex: (lyricIndex + 1) % lyrics.length,
        });
      });
      holdSeconds = 0;
      // Restart timers for new holder
      startLyricTimer(gameRef);
    }
  }, 1000);
}

async function eliminateCurrentHolderAndRestart(gameRef) {
  const snap = await getDoc(gameRef);
  if (!snap.exists()) return;
  const game = snap.data();
  const eliminatedId = game.potatoHolder;

  const batch = writeBatch(db);
  // Mark eliminated player as not alive
  const playerIndex = game.players.findIndex(p => p.id === eliminatedId);
  if (playerIndex >= 0) {
    const playerRef = doc(db, "games", gameId);
    const players = [...game.players];
    players[playerIndex] = { ...players[playerIndex], alive: false };
    batch.update(playerRef, { players });
  }

  // Remove eliminated player from the game if their tab closed (handled in onDisconnect)
  await batch.commit();

  // Check if game is over
  const alivePlayers = game.players.filter(p => p.alive && p.id !== eliminatedId);
  if (alivePlayers.length <= 1) {
    // Game over: restart lobby, reset everything
    await setDoc(gameRef, {
      players: alivePlayers,
      state: "lobby",
      host: alivePlayers.length === 1 ? alivePlayers[0].id : null,
      potatoHolder: null,
      lyricIndex: 0
    });
    alert(alivePlayers.length === 1 ? `Game over! Winner: ${alivePlayers[0].name}` : "Game over! No winner.");
    showLobby();
  } else {
    // Start next round with new potato holder randomly chosen
    const newHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
    await updateDoc(gameRef, {
      potatoHolder: newHolder,
      lyricIndex: 0,
    });
    lyricIndex = 0;
    currentPlayerClicks = 0;
    holdSeconds = 0;
    // Restart timers for new holder
    startLyricTimer(gameRef);
  }
}

function clearTimers() {
  if (lyricInterval) {
    clearInterval(lyricInterval);
    lyricInterval = null;
  }
  if (holdTimerInterval) {
    clearInterval(holdTimerInterval);
    holdTimerInterval = null;
  }
  holdSeconds = 0;
  currentPlayerClicks = 0;
  clickCountDisplay.textContent = "0";
  holdTimerDisplay.textContent = "0";
}

function showLobby() {
  gameArea.style.di
