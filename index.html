<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hot Potato Game</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background-color: #ffe6f0;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    color: #ff4da6;
  }
  button {
    background-color: #ff80bf;
    border: none;
    padding: 10px 15px;
    margin: 5px;
    cursor: pointer;
    color: white;
    border-radius: 8px;
    font-size: 14px;
  }
  button:hover {
    background-color: #ff4da6;
  }
  #gameArea {
    display: none;
    margin-top: 20px;
  }
  #lobbyArea {
    margin-top: 20px;
  }
  .player {
    padding: 8px 12px;
    background-color: #fff0f5;
    border: 1px solid #ffb3d9;
    border-radius: 6px;
    margin: 5px;
  }
  .player.host {
    border: 2px solid gold;
  }
  .player.out {
    color: #bbb;
    text-decoration: line-through;
  }
</style>
</head>
<body>

<h1>Hot Potato Game</h1>

<div id="lobbyArea">
  <input type="text" id="username" placeholder="Enter your name" />
  <button id="joinGame">Join Game</button>
  <div id="playerList"></div>
  <button id="startGame" style="display:none;">Start Game</button>
</div>

<div id="gameArea">
  <h2 id="potatoStatus">Waiting...</h2>
  <button id="passPotato">Click to Pass Potato</button>
  <p>Clicks: <span id="clickCount">0</span></p>
  <p>Pass Timer: <span id="passTimer">5</span> seconds</p>
  <div id="lyricDisplay" style="font-size: 24px; margin-top: 10px; font-weight: bold;"></div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import {
    getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, arrayUnion, runTransaction
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB2_jo_IniRf7IYXmdziTN4yezDxjZxTD0",
    authDomain: "hotpotatoe-12db7.firebaseapp.com",
    projectId: "hotpotatoe-12db7",
    storageBucket: "hotpotatoe-12db7.firebasestorage.app",
    messagingSenderId: "495938423140",
    appId: "1:495938423140:web:ee57563ed78bbe5f41d271",
    measurementId: "G-TRN809H4JK"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ===== GAME VARIABLES =====
  let playerId = null;
  let playerName = "";
  const gameId = "main-room";
  let potatoHolder = null;
  const lyrics = ["hot", "potato", "hot", "potato", "hot", "potato", "hot", "potato", "if", "you", "have", "the", "Potato", "you", "are", "out!"];
  let lyricIndex = 0;

  // ===== UI ELEMENTS =====
  const usernameInput = document.getElementById("username");
  const joinBtn = document.getElementById("joinGame");
  const startBtn = document.getElementById("startGame");
  const playerListEl = document.getElementById("playerList");
  const gameArea = document.getElementById("gameArea");
  const potatoStatus = document.getElementById("potatoStatus");
  const passBtn = document.getElementById("passPotato");
  const lyricDisplay = document.getElementById("lyricDisplay");
  const clickCountEl = document.getElementById("clickCount");
  const passTimerEl = document.getElementById("passTimer");

  // ===== TIMER & CLICK TRACKING =====
  let localClicks = 0;
  let lyricInterval = null;
  let passTimer = 5;
  let passTimerInterval = null;

  // ===== JOIN GAME =====
  joinBtn.addEventListener("click", async () => {
    playerName = usernameInput.value.trim();
    if (!playerName) return alert("Enter your name!");

    playerId = `${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    const gameRef = doc(db, "games", gameId);
    const snap = await getDoc(gameRef);

    if (!snap.exists()) {
      await setDoc(gameRef, {
        players: [],
        state: "lobby",
        host: playerId,
        potatoHolder: null,
        lyricIndex: 0
      });
    }

    // Add player if not already in list (avoid duplicates)
    const game = (await getDoc(gameRef)).data();
    if (!game.players.some(p => p.id === playerId)) {
      await updateDoc(gameRef, {
        players: arrayUnion({ id: playerId, name: playerName, alive: true, clicks: 0, lastActive: Date.now() })
      });
    } else {
      // Update lastActive if player re-joins
      const updatedPlayers = game.players.map(p => {
        if (p.id === playerId) {
          return { ...p, lastActive: Date.now() };
        }
        return p;
      });
      await updateDoc(gameRef, { players: updatedPlayers });
    }

    listenForGameUpdates();
  });

  // ===== LISTEN FOR GAME UPDATES =====
  function listenForGameUpdates() {
    const gameRef = doc(db, "games", gameId);
    onSnapshot(gameRef, (snap) => {
      if (!snap.exists()) return;
      const game = snap.data();

      renderPlayers(game.players, game.host);

      if (game.state === "playing") {
        document.getElementById("lobbyArea").style.display = "none";
        gameArea.style.display = "block";

        potatoHolder = game.potatoHolder;
        lyricIndex = game.lyricIndex ?? 0;

        lyricDisplay.textContent = lyrics[lyricIndex] || "";

        // Update clicks if this player has the potato
        if (potatoHolder === playerId) {
          const playerData = game.players.find(p => p.id === playerId);
          localClicks = playerData?.clicks || 0;
          clickCountEl.textContent = localClicks;
          startPassTimer();
        } else {
          localClicks = 0;
          clickCountEl.textContent = 0;
          stopPassTimer();
        }

        potatoStatus.textContent =
          potatoHolder === playerId
            ? "You have the potato!"
            : `${game.players.find((p) => p.id === potatoHolder)?.name || "Unknown"} has the potato`;
      } else {
        // Show lobby UI if not playing
        document.getElementById("lobbyArea").style.display = "block";
        gameArea.style.display = "none";
        stopLyricsFlow();
        stopPassTimer();
      }
    });
  }

  // ===== RENDER PLAYERS IN LOBBY =====
  function renderPlayers(players, hostId) {
    playerListEl.innerHTML = "";
    players.forEach((p) => {
      const div = document.createElement("div");
      div.className = "player";
      if (p.id === hostId) div.classList.add("host");
      if (!p.alive) div.classList.add("out");
      div.textContent = p.name + (p.alive ? "" : " (out)");
      playerListEl.appendChild(div);
    });
    if (hostId === playerId) {
      startBtn.style.display = "inline-block";
    } else {
      startBtn.style.display = "none";
    }
  }

  // ===== REMOVE OFFLINE PLAYERS =====
  async function removeOfflinePlayers(players) {
    // Define "offline" as not updated lastActive in last 20 seconds
    const now = Date.now();
    const offlineThreshold = 20 * 1000;

    const offlinePlayers = players.filter(p => (now - (p.lastActive || 0)) > offlineThreshold && p.alive);

    if (offlinePlayers.length === 0) return;

    const gameRef = doc(db, "games", gameId);

    await runTransaction(db, async (transaction) => {
      const snap = await transaction.get(gameRef);
      const game = snap.data();

      // Mark offline players as out
      const updatedPlayers = game.players.map(p => {
        if (offlinePlayers.some(op => op.id === p.id)) {
          return {...p, alive: false, clicks: 0};
        }
        return p;
      });

      transaction.update(gameRef, { players: updatedPlayers });
    });
  }

  // ===== START GAME =====
  startBtn.addEventListener("click", async () => {
    const gameRef = doc(db, "games", gameId);
    const snap = await getDoc(gameRef);
    const game = snap.data();
    if (game.host !== playerId) return;

    // Remove offline players before starting
    await removeOfflinePlayers(game.players);

    // Re-fetch after cleanup
    const newSnap = await getDoc(gameRef);
    const newGame = newSnap.data();

    const alivePlayers = newGame.players.filter((p) => p.alive);
    if (alivePlayers.length < 2) {
      alert("Need at least 2 players alive to start.");
      return;
    }

    const randomHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;

    await updateDoc(gameRef, {
      state: "playing",
      potatoHolder: randomHolder,
      lyricIndex: 0
    });

    lyricIndex = 0;
    startLyricsFlow();
  });

  // ===== PASS POTATO BUTTON CLICK =====
  passBtn.addEventListener("click", async () => {
    if (potatoHolder !== playerId) return;

    localClicks++;
    clickCountEl.textContent = localClicks;

    const gameRef = doc(db, "games", gameId);
    await runTransaction(db, async (transaction) => {
      const snap = await transaction.get(gameRef);
      const game = snap.data();

      // Update player's clicks count in players array
      const updatedPlayers = game.players.map(p => {
        if (p.id === playerId) {
          return { ...p, clicks: localClicks, lastActive: Date.now() };
        }
        return p;
      });

      transaction.update(gameRef, { players: updatedPlayers });

      if (localClicks >= 5) {
        // Auto pass potato after 5 clicks
        const alivePlayers = game.players.filter(p => p.alive && p.id !== playerId);
        if (alivePlayers.length === 0) return;
        const nextHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;

        transaction.update(gameRef, { potatoHolder: nextHolder });

        // Reset local clicks and update Firestore
        localClicks = 0;
        clickCountEl.textContent = localClicks;
        const resetPlayers = updatedPlayers.map(p => p.id === playerId ? {...p, clicks: 0} : p);
        transaction.update(gameRef, { players: resetPlayers });

        resetPassTimer();
      }
    });
  });

  // ===== LYRICS FLOW =====
  function startLyricsFlow() {
    if (lyricInterval) return; // prevent multiple intervals

    lyricInterval = setInterval(async () => {
      lyricIndex++;
      if (lyricIndex >= lyrics.length) {
        clearInterval(lyricInterval);
        lyricInterval = null;

        // The player holding potato at the end is out:
        const gameRef = doc(db, "games", gameId);
        await runTransaction(db, async (transaction) => {
          const snap = await transaction.get(gameRef);
          const game = snap.data();

          // Mark current potato holder as out
          const updatedPlayers = game.players.map(p => 
            p.id === game.potatoHolder ? {...p, alive: false, clicks: 0} : p
          );

          transaction.update(gameRef, {
            players: updatedPlayers,
            potatoHolder: null,
            lyricIndex: 0
          });
        });

        alert("Player holding the potato is out! Starting next round.");

        // Restart game automatically if enough players left
        const gameRef2 = doc(db, "games", gameId);
        const snap2 = await getDoc(gameRef2);
        const game2 = snap2.data();

        const alivePlayers = game2.players.filter(p => p.alive);
        if (alivePlayers.length >= 2) {
          const randomHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
          await updateDoc(gameRef2, {
            state: "playing",
            potatoHolder: randomHolder,
            lyricIndex: 0
          });
          lyricIndex = 0;
          startLyricsFlow();
        } else {
          // Not enough players: go to lobby
          await updateDoc(gameRef2, {
            state: "lobby",
            potatoHolder: null,
            lyricIndex: 0
          });
          alert("Not enough players alive to continue. Back to lobby.");
        }

        return;
      }

      // Update lyric index in Firestore
      const gameRef = doc(db, "games", gameId);
      await updateDoc(gameRef, { lyricIndex });

    }, 900);
  }

  function stopLyricsFlow() {
    if (lyricInterval) {
      clearInterval(lyricInterval);
      lyricInterval = null;
    }
  }

  // ===== PASS TIMER =====
  function startPassTimer() {
    passTimer = 5;
    passTimerEl.textContent = passTimer;

    if (passTimerInterval) clearInterval(passTimerInterval);

    passTimerInterval = setInterval(async () => {
      passTimer--;
      passTimerEl.textContent = passTimer;

      if (passTimer <= 0) {
        clearInterval(passTimerInterval);
        passTimerInterval = null;

        if (potatoHolder === playerId) {
          // Force pass potato if timer runs out
          const gameRef = doc(db, "games", gameId);
          await runTransaction(db, async (transaction) => {
            const snap = await transaction.get(gameRef);
            const game = snap.data();
            const alivePlayers = game.players.filter(p => p.alive && p.id !== playerId);
            if (alivePlayers.length === 0) return;
            const nextHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;

            transaction.update(gameRef, { potatoHolder: nextHolder });

            // Reset clicks for this player
            const updatedPlayers = game.players.map(p => p.id === playerId ? {...p, clicks: 0} : p);
            transaction.update(gameRef, { players: updatedPlayers });

            localClicks = 0;
            clickCountEl.textContent = localClicks;
          });
        }
      }
    }, 1000);
  }

  function stopPassTimer() {
    if (passTimerInterval) {
      clearInterval(passTimerInterval);
      passTimerInterval = null;
      passTimerEl.textContent = "5";
    }
  }
</script>
</body>
</html>
