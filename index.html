<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hot Potato Game</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background-color: #ffe6f0;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; align-items: center;
  }
  h1 {
    color: #ff4da6;
  }
  button {
    background-color: #ff80bf;
    border: none;
    padding: 10px 15px;
    margin: 5px;
    cursor: pointer;
    color: white;
    border-radius: 8px;
    font-size: 14px;
  }
  button:hover:not(:disabled) {
    background-color: #ff4da6;
  }
  button:disabled {
    background-color: #ffcce0;
    cursor: not-allowed;
  }
  #gameArea, #lobbyArea {
    margin-top: 20px;
    width: 300px;
    text-align: center;
  }
  #playerList div {
    padding: 8px 12px;
    background-color: #fff0f5;
    border: 1px solid #ffb3d9;
    border-radius: 6px;
    margin: 5px 0;
  }
  #playerList div.host {
    border: 2px solid gold;
  }
  #playerList div.out {
    background-color: #f0f0f0;
    color: #999;
    text-decoration: line-through;
  }
  #lyricDisplay {
    font-size: 24px;
    font-weight: bold;
    margin: 20px 0;
  }
  #potatoStatus {
    font-weight: bold;
    margin-bottom: 10px;
  }
  #clicksDisplay {
    margin: 10px 0;
    font-size: 18px;
  }
  #holdTimer {
    font-size: 18px;
    color: #ff4d4d;
    margin: 10px 0;
  }
</style>
</head>
<body>

<h1>Hot Potato Game</h1>

<div id="lobbyArea">
  <input type="text" id="username" placeholder="Enter your name" autocomplete="off" />
  <button id="joinGame">Join Game</button>
  <div id="playerList"></div>
  <button id="startGame" style="display:none;">Start Game</button>
  <div id="status"></div>
</div>

<div id="gameArea" style="display:none;">
  <div id="potatoStatus">Waiting for game to start...</div>
  <button id="passPotato">Pass Potato (Click 5 times)</button>
  <div id="clicksDisplay">Clicks: 0</div>
  <div id="holdTimer">Time left to hold potato: 5s</div>
  <div id="lyricDisplay"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot,
  arrayUnion, runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB2_jo_IniRf7IYXmdziTN4yezDxjZxTD0",
  authDomain: "hotpotatoe-12db7.firebaseapp.com",
  projectId: "hotpotatoe-12db7",
  storageBucket: "hotpotatoe-12db7.firebasestorage.app",
  messagingSenderId: "495938423140",
  appId: "1:495938423140:web:ee57563ed78bbe5f41d271",
  measurementId: "G-TRN809H4JK"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const gameId = "main-room";
const gameRef = doc(db, "games", gameId);

const lyrics = ["hot", "potato", "hot", "potato", "hot", "potato", "hot", "potato", "if", "you", "have", "the", "Potato", "you", "are", "out!"];
const clicksNeededToPass = 5;
const maxHoldTime = 5; // seconds before forced pass

// DOM elements
const usernameInput = document.getElementById("username");
const joinBtn = document.getElementById("joinGame");
const startBtn = document.getElementById("startGame");
const playerListEl = document.getElementById("playerList");
const lobbyArea = document.getElementById("lobbyArea");
const gameArea = document.getElementById("gameArea");
const potatoStatus = document.getElementById("potatoStatus");
const passBtn = document.getElementById("passPotato");
const lyricDisplay = document.getElementById("lyricDisplay");
const clicksDisplay = document.getElementById("clicksDisplay");
const holdTimer = document.getElementById("holdTimer");
const statusDiv = document.getElementById("status");

let playerId = null;
let playerName = "";
let lyricIndex = 0;
let localClicks = 0;
let potatoHolder = null;
let holdInterval = null;
let holdSecondsLeft = maxHoldTime;
let lyricInterval = null;
let holdTimerInterval = null;
let joined = false;

// Disable join button to prevent spam
function setJoinButtonDisabled(disabled) {
  joinBtn.disabled = disabled;
  usernameInput.disabled = disabled;
}

// When user closes or reloads tab, remove player from game
window.addEventListener("beforeunload", async () => {
  if (!playerId) return;
  try {
    const snap = await getDoc(gameRef);
    if (!snap.exists()) return;
    const game = snap.data();
    if (!game.players) return;
    const updatedPlayers = game.players.filter(p => p.id !== playerId);
    await updateDoc(gameRef, { players: updatedPlayers });
  } catch (e) {
    // ignore errors on unload
  }
});

joinBtn.onclick = async () => {
  if (joined) return; // already joined, prevent spam

  playerName = usernameInput.value.trim();
  if (!playerName) {
    alert("Please enter your name!");
    return;
  }

  setJoinButtonDisabled(true);

  try {
    playerId = `${Date.now()}-${Math.floor(Math.random() * 1000)}`;

    const snap = await getDoc(gameRef);
    let game = snap.exists() ? snap.data() : null;

    if (!game) {
      // Create new game and assign host as first player
      await setDoc(gameRef, {
        players: [{ id: playerId, name: playerName, alive: true, clicks: 0 }],
        state: "lobby",
        host: playerId,
        potatoHolder: null,
        lyricIndex: 0
      });
    } else {
      let playersArray = Array.isArray(game.players) ? game.players : [];
      // If no host, assign first player as host
      let hostId = game.host;
      if (!hostId) {
        hostId = playerId;
      }
      // Add player if not in list
      if (!playersArray.some(p => p.id === playerId)) {
        playersArray.push({ id: playerId, name: playerName, alive: true, clicks: 0 });
      }
      await updateDoc(gameRef, {
        players: playersArray,
        host: hostId
      });
    }

    joined = true;
    statusDiv.textContent = "Joined lobby. Waiting for host to start the game.";
    listenForGameUpdates();
  } catch (e) {
    alert("Error joining game, try again.");
    console.error(e);
  }

  setJoinButtonDisabled(false);
};

startBtn.onclick = async () => {
  const snap = await getDoc(gameRef);
  const game = snap.data();
  if (game.host !== playerId) {
    alert("Only the host can start the game!");
    return;
  }
  const alivePlayers = game.players.filter(p => p.alive);
  if (alivePlayers.length < 2) {
    alert("Need at least 2 players to start!");
    return;
  }
  const randomHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;

  await updateDoc(gameRef, {
    state: "playing",
    potatoHolder: randomHolder,
    lyricIndex: 0
  });

  lyricIndex = 0;
  localClicks = 0;
  holdSecondsLeft = maxHoldTime;
  holdTimer.textContent = `Time left to hold potato: ${holdSecondsLeft}s`;
};

passBtn.onclick = async () => {
  if (potatoHolder !== playerId) return;

  localClicks++;
  clicksDisplay.textContent = `Clicks: ${localClicks}`;

  if (localClicks >= clicksNeededToPass) {
    await passPotato();
  }
};

async function passPotato() {
  localClicks = 0;
  clicksDisplay.textContent = `Clicks: 0`;
  holdSecondsLeft = maxHoldTime;
  holdTimer.textContent = `Time left to hold potato: ${holdSecondsLeft}s`;

  await runTransaction(db, async (transaction) => {
    const snap = await transaction.get(gameRef);
    if (!snap.exists()) throw "Game doc missing";
    const game = snap.data();
    const alivePlayers = game.players.filter(p => p.alive && p.id !== potatoHolder);
    if (alivePlayers.length === 0) return; // no one else alive
    const nextHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;

    // Reset clicks for all players
    const resetPlayers = game.players.map(p => {
      if (p.id === potatoHolder || p.id === nextHolder) {
        return { ...p, clicks: 0 };
      }
      return p;
    });

    transaction.update(gameRef, { potatoHolder: nextHolder, players: resetPlayers });
  });
}

function listenForGameUpdates() {
  onSnapshot(gameRef, async (snap) => {
    if (!snap.exists()) return;
    const game = snap.data();

    if (!game.players) return;

    renderPlayers(game.players, game.host);

    if (game.state === "playing") {
      lobbyArea.style.display = "none";
      gameArea.style.display = "block";

      potatoHolder = game.potatoHolder;
      lyricIndex = game.lyricIndex ?? 0;

      if (potatoHolder === playerId) {
        potatoStatus.textContent = "You have the potato!";
      } else {
        const holderName = game.players.find(p => p.id === potatoHolder)?.name ?? "Unknown";
        potatoStatus.textContent = `${holderName} has the potato`;
      }

      const localPlayer = game.players.find(p => p.id === playerId);
      localClicks = localPlayer?.clicks ?? 0;
      clicksDisplay.textContent = `Clicks: ${localClicks}`;

      lyricDisplay.textContent = lyrics[lyricIndex];

      if (game.host === playerId) {
        startLyricFlow(game);
      }
    } else {
      lobbyArea.style.display = "block";
      gameArea.style.display = "none";

      potatoHolder = null;
      lyricIndex = 0;
      localClicks = 0;
      clicksDisplay.textContent = "Clicks: 0";
      holdTimer.textContent = "";
      lyricDisplay.textContent = "";
    }
  });
}

let lyricInterval = null;
let holdTimerInterval = null;
const lyricTickMs = 900;

function startLyricFlow(game) {
  if (lyricInterval) return;

  lyricInterval = setInterval(async () => {
    lyricIndex++;

    if (lyricIndex >= lyrics.length) {
      clearInterval(lyricInterval);
      lyricInterval = null;

      // End round - eliminate holder
      const snap = await getDoc(gameRef);
      const currentGame = snap.data();
      const currentHolder = currentGame.potatoHolder;

      if (currentHolder) {
        const updatedPlayers = currentGame.players.map(p => {
          if (p.id === currentHolder) return { ...p, alive: false };
          return p;
        });

        await updateDoc(gameRef, { players: updatedPlayers });
      }

      await startNextRoundOrEnd(currentGame);
      return;
    }

    await updateDoc(gameRef, { lyricIndex });
  }, lyricTickMs);

  startHoldTimer(game);
}

function startHoldTimer(game) {
  if (holdTimerInterval) return;

  holdSecondsLeft = maxHoldTime;
  holdTimer.textContent = `Time left to hold potato: ${holdSecondsLeft}s`;

  holdTimerInterval = setInterval(async () => {
    holdSecondsLeft--;
    holdTimer.textContent = `Time left to hold potato: ${holdSecondsLeft}s`;

    if (holdSecondsLeft <= 0) {
      clearInterval(holdTimerInterval);
      holdTimerInterval = null;

      if (game.host === playerId) {
        await passPotato();
      }
    }
  }, 1000);
}

async function startNextRoundOrEnd(game) {
  const alivePlayers = game.players.filter(p => p.alive);

  if (alivePlayers.length <= 1) {
    const winnerName = alivePlayers.length === 1 ? alivePlayers[0].name : "No one";
    alert(`Game over! Winner: ${winnerName}`);

    // Reset players alive for new game
    const resetPlayers = game.players.map(p => ({ ...p, alive: true, clicks: 0 }));

    await updateDoc(gameRef, {
      state: "lobby",
      potatoHolder: null,
      lyricIndex: 0,
      players: resetPlayers
    });

    lobbyArea.style.display = "block";
    gameArea.style.display = "none";

    lyricIndex = 0;
    localClicks = 0;
    potatoHolder = null;
    holdTimer.textContent = "";
    clicksDisplay.textContent = "Clicks: 0";

  } else {
    const newHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
    const resetPlayers = game.players.map(p => {
      if (alivePlayers.some(ap => ap.id === p.id)) {
        return { ...p, clicks: 0 };
      }
      return p;
    });

    await updateDoc(gameRef, {
      state: "playing",
      potatoHolder: newHolder,
      lyricIndex: 0,
      players: resetPlayers
    });

    lyricIndex = 0;
    localClicks = 0;
    holdSecondsLeft = maxHoldTime;
    holdTimer.textContent = `Time left to hold potato: ${holdSecondsLeft}s`;
  }
}

function renderPlayers(players, hostId) {
  playerListEl.innerHTML = "";
  if (!players) return;
  players.forEach(p => {
    const div = document.createElement("div");
    div.textContent = p.name + (p.alive ? "" : " (out)");
    div.className = "";
    if (p.id === hostId) div.classList.add("host");
    if (!p.alive) div.classList.add("out");
    playerListEl.appendChild(div);
  });

  startBtn.style.display = (hostId === playerId && players.filter(p => p.alive).length >= 2) ? "inline-block" : "none";
}
</script>
</body>
</html>
