<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hot Potato Game</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: linear-gradient(to bottom, #ff4500, #8b0000);
    margin: 0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #fff;
  }
  h1 {
    color: #ffd700;
    text-shadow: 2px 2px #8b0000;
  }
  button {
    background: #ff4500;
    border: none;
    padding: 10px 15px;
    margin: 5px;
    cursor: pointer;
    color: #fff;
    border-radius: 8px;
    font-size: 14px;
  }
  button:hover {
    background: #cc0000;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  #gameArea, #startGame, #leaveGame {
    display: none;
  }
  #playerList {
    margin: 10px 0;
    width: 200px;
  }
  .player {
    padding: 8px 12px;
    background: #ff6347;
    border: 1px solid #ffd700;
    border-radius: 6px;
    margin: 3px;
    display: flex;
    justify-content: space-between;
    color: #fff;
  }
  .player.host {
    border: 2px solid #ffd700;
    font-weight: bold;
  }
  #lyricDisplay {
    font-size: 24px;
    font-weight: bold;
    margin: 20px 0;
    color: #ffd700;
  }
  #potatoStatus {
    margin-bottom: 10px;
    color: #fff;
  }
  #clicksDisplay {
    font-weight: bold;
    margin-bottom: 10px;
    color: #fff;
  }
  #potatoTimerDisplay {
    margin-top: 5px;
    font-size: 14px;
    color: #ffd700;
  }
  #statusBar {
    margin-top: 15px;
    color: #ffd700;
    min-height: 18px;
  }
  #playerDiagram {
    position: relative;
    width: 400px;
    height: 400px;
    margin: 20px auto;
  }
  #hotPotatoImage {
    max-width: 200px;
    margin-bottom: 20px;
  }
</style>
</head>
<body>

<img id="hotPotatoImage" src="https://png.pngtree.com/png-vector/20220917/ourmid/pngtree-hot-potato-saying-cartoon-dangerous-proverb-drawing-vector-png-image_14545442.png" alt="Hot Potato" />
<h1>Hot Potato Game</h1>
<p id="currentRoom">Current Room: <span id="roomDisplay"></span></p>

<div id="lobbyArea">
  <input type="text" id="username" placeholder="Enter your name" />
  <button id="joinGame">Join Game</button>
  <button id="leaveGame">Leave Game</button>
  <div id="playerList"></div>
  <button id="startGame">Start Game</button>
</div>

<div id="gameArea">
  <div id="potatoStatus">Waiting for game to start...</div>
  <div id="clicksDisplay">Your clicks: 0</div>
  <button id="passPotato">Click Potato</button>
  <div id="potatoTimerDisplay"></div>
  <div id="lyricDisplay"></div>
  <div id="playerDiagram"></div>
</div>

<div id="statusBar"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, arrayUnion, arrayRemove, runTransaction,
  collection, query, where, getDocs
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB2_jo_IniRf7IYXmdziTN4yezDxjZxTD0",
  authDomain: "hotpotatoe-12db7.firebaseapp.com",
  projectId: "hotpotatoe-12db7",
  storageBucket: "hotpotatoe-12db7.firebasestorage.app",
  messagingSenderId: "495938423140",
  appId: "1:495938423140:web:ee57563ed78bbe5f41d271",
  measurementId: "G-TRN809H4JK"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const lyrics = [
  "hot", "potato", "hot", "potato", "hot", "potato", "hot", "potato",
  "if", "you", "have", "the", "Potato", "you", "are", "out!"
];
const clicksToPass = 5;
const potatoMaxHoldSeconds = 5;
const outIndex = lyrics.indexOf("out!");

let gameId = localStorage.getItem('gameId') || null;
let playerId = localStorage.getItem('playerId') || null;
let playerName = localStorage.getItem('playerName') || "";
let potatoHolder = null;
let prevPotatoHolder = null;
let lyricIndex = 0;
let playerClicks = 0;
let holdTimer = null;
let holdSecondsLeft = potatoMaxHoldSeconds;
let isHost = false;
let joined = false;
let gameUnsub = null;
let lyricTimer = null;

const usernameInput = document.getElementById("username");
const joinBtn = document.getElementById("joinGame");
const leaveBtn = document.getElementById("leaveGame");
const startBtn = document.getElementById("startGame");
const playerListEl = document.getElementById("playerList");
const gameArea = document.getElementById("gameArea");
const potatoStatus = document.getElementById("potatoStatus");
const clicksDisplay = document.getElementById("clicksDisplay");
const passBtn = document.getElementById("passPotato");
const potatoTimerDisplay = document.getElementById("potatoTimerDisplay");
const lyricDisplay = document.getElementById("lyricDisplay");
const statusBar = document.getElementById("statusBar");
const lobbyArea = document.getElementById("lobbyArea");
const roomDisplay = document.getElementById("roomDisplay");

if(playerId && playerName && gameId) {
  usernameInput.value = playerName;
  joined = true;
  joinBtn.style.display = "none";
  leaveBtn.style.display = "inline-block";
  roomDisplay.textContent = gameId;
  listenForGameUpdates();
} else {
  gameId = null;
}

function setStatus(text) {
  statusBar.textContent = text;
}

function resetHoldTimer() {
  if(holdTimer) clearInterval(holdTimer);
  holdSecondsLeft = potatoMaxHoldSeconds;
  updateHoldTimerDisplay();
  holdTimer = setInterval(() => {
    holdSecondsLeft--;
    updateHoldTimerDisplay();
    if(holdSecondsLeft <= 0) {
      passPotatoDueToTimeout();
    }
  }, 1000);
}

function updateHoldTimerDisplay() {
  potatoTimerDisplay.textContent = `Pass potato in: ${holdSecondsLeft}s`;
}

function stopHoldTimer() {
  if(holdTimer) {
    clearInterval(holdTimer);
    holdTimer = null;
    potatoTimerDisplay.textContent = "";
  }
}

joinBtn.addEventListener("click", async () => {
  if(joined) return;
  playerName = usernameInput.value.trim();
  if(!playerName) {
    alert("Please enter your name!");
    return;
  }
  if(playerId) {
    alert("You have already joined the game on this device.");
    return;
  }

  playerId = `${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  let targetGameId = 'main-room';
  let gameRef = doc(db, "games", targetGameId);
  let snap = await getDoc(gameRef);

  if (snap.exists() && snap.data().state === "playing") {
    setStatus("Main room in progress. Searching for an open lobby...");
    const gamesRef = collection(db, "games");
    const q = query(gamesRef, where("state", "==", "lobby"));
    const querySnapshot = await getDocs(q);
    let foundLobby = false;

    for (const doc of querySnapshot.docs) {
      if (doc.id !== 'main-room') {
        targetGameId = doc.id;
        gameRef = doc(db, "games", targetGameId);
        snap = await getDoc(gameRef);
        foundLobby = true;
        setStatus(`Joining existing lobby: ${targetGameId}`);
        break;
      }
    }

    if (!foundLobby) {
      setStatus("No open lobbies found. Creating new lobby.");
      targetGameId = `room-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      gameRef = doc(db, "games", targetGameId);
      snap = await getDoc(gameRef);
    }
  }

  try {
    if (!snap.exists()) {
      await setDoc(gameRef, {
        players: [],
        state: "lobby",
        host: playerId,
        potatoHolder: null,
        lyricIndex: 0
      });
      isHost = true;
    } else {
      const gameData = snap.data();
      isHost = (gameData.host === playerId);
    }
    await updateDoc(gameRef, {
      players: arrayUnion({ id: playerId, name: playerName, alive: true })
    });
    localStorage.setItem('playerId', playerId);
    localStorage.setItem('playerName', playerName);
    localStorage.setItem('gameId', targetGameId);
    gameId = targetGameId;
    roomDisplay.textContent = gameId;
    joined = true;
    joinBtn.style.display = "none";
    leaveBtn.style.display = "inline-block";
    listenForGameUpdates();
    setStatus("Joined game lobby.");
  } catch (err) {
    console.error(err);
    setStatus("Error joining game.");
  }
});

leaveBtn.addEventListener("click", async () => {
  if(!joined) return;
  await leaveGame();
});

startBtn.addEventListener("click", async () => {
  if (!joined) return;
  if (!isHost) {
    alert("Only the host can start the game.");
    return;
  }
  const gameRef = doc(db, "games", gameId);
  const snap = await getDoc(gameRef);
  if (!snap.exists()) return;
  const game = snap.data();
  const alivePlayers = game.players.filter(p => p.alive);
  if (alivePlayers.length < 2) {
    alert("Need at least 2 players to start.");
    return;
  }
  const randomHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
  await updateDoc(gameRef, {
    state: "playing",
    potatoHolder: randomHolder,
    lyricIndex: 0
  });
  lyricIndex = 0;
  playerClicks = 0;
  setStatus("Game started!");
});

passBtn.addEventListener("click", async () => {
  if (potatoHolder !== playerId) return;
  const gameRef = doc(db, "games", gameId);
  try {
    await runTransaction(db, async (transaction) => {
      const snap = await transaction.get(gameRef);
      if (!snap.exists()) {
        throw new Error("Game document does not exist");
      }
      const game = snap.data();
      const alivePlayers = game.players.filter(p => p.alive && p.id !== playerId);
      if (alivePlayers.length === 0) {
        playerClicks = 0;
        setStatus("No other players available!");
        return;
      }
      playerClicks++;
      if (playerClicks >= clicksToPass) {
        const newHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
        transaction.update(gameRef, {
          potatoHolder: newHolder
        });
        playerClicks = 0;
      }
    });
    clicksDisplay.textContent = `Your clicks: ${playerClicks}/${clicksToPass}`;
    resetHoldTimer();
  } catch (e) {
    console.error("Transaction failed:", e);
    setStatus("Error passing potato. Please try again.");
  }
});

async function passPotatoDueToTimeout() {
  const gameRef = doc(db, "games", gameId);
  try {
    await runTransaction(db, async (transaction) => {
      const snap = await transaction.get(gameRef);
      if (!snap.exists()) {
        throw new Error("Game document does not exist");
      }
      const game = snap.data();
      if (game.potatoHolder !== playerId) return;

      const alivePlayers = game.players.filter(p => p.alive && p.id !== playerId);
      if (alivePlayers.length === 0) {
        setStatus("No other players available!");
        return;
      }

      const newHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
      transaction.update(gameRef, {
        potatoHolder: newHolder
      });
      playerClicks = 0;
    });
    clicksDisplay.textContent = `Your clicks: ${playerClicks}/${clicksToPass}`;
  } catch (e) {
    console.error("Transaction failed:", e);
    setStatus("Error passing potato due to timeout. Please try again.");
  }
}

function listenForGameUpdates() {
  if (!gameId) return;
  const gameRef = doc(db, "games", gameId);

  if(gameUnsub) gameUnsub();

  gameUnsub = onSnapshot(gameRef, async (snap) => {
    if (!snap.exists()) return;
    const game = snap.data();

    // If no valid host or host is not alive, assign first alive player as host
    if (!game.host || !game.players.some(p => p.id === game.host && p.alive)) {
      const firstAlive = game.players.find(p => p.alive);
      if (firstAlive) {
        try {
          await updateDoc(gameRef, { host: firstAlive.id });
          if(firstAlive.id === playerId) isHost = true;
        } catch (e) {
          console.error(e);
        }
      }
    } else {
      isHost = (game.host === playerId);
    }

    renderPlayers(game.players, game.host);

    if (game.state === "lobby") {
      setStartButton(isHost && game.players.filter(p => p.alive).length >= 2);
      gameArea.style.display = "none";
      lobbyArea.style.display = "block";
      potatoStatus.textContent = "Waiting for game to start...";
      lyricDisplay.textContent = "";
      clicksDisplay.textContent = "";
      potatoTimerDisplay.textContent = "";
      playerClicks = 0;
      stopHoldTimer();
      passBtn.style.display = "none";
      if(lyricTimer) {
        clearInterval(lyricTimer);
        lyricTimer = null;
      }
    } else if (game.state === "playing") {
      lobbyArea.style.display = "none";
      gameArea.style.display = "block";
      potatoHolder = game.potatoHolder;
      lyricIndex = game.lyricIndex || 0;

      lyricDisplay.textContent = lyrics[lyricIndex] || "";

      if (potatoHolder === playerId) {
        if (prevPotatoHolder !== potatoHolder) {
          playerClicks = 0;
          clicksDisplay.textContent = `Your clicks: ${playerClicks}/${clicksToPass}`;
        }
        potatoStatus.textContent = "You have the potato!";
        clicksDisplay.textContent = `Your clicks: ${playerClicks}/${clicksToPass}`;
        passBtn.style.display = "inline-block";
        resetHoldTimer();
      } else {
        const holderName = (game.players.find(p => p.id === potatoHolder) || {}).name || "Someone";
        potatoStatus.textContent = `${holderName} has the potato`;
        clicksDisplay.textContent = "";
        passBtn.style.display = "none";
        stopHoldTimer();
      }
      prevPotatoHolder = potatoHolder;

      renderDiagram(game.players, game.potatoHolder);

      const me = game.players.find(p => p.id === playerId);
      if (!me || !me.alive) {
        alert("You are out!");
        await leaveGame();
      }

      if (isHost && !lyricTimer) {
        lyricTimer = setInterval(async () => {
          try {
            await runTransaction(db, async (transaction) => {
              const snap = await transaction.get(gameRef);
              if (!snap.exists()) return;
              const game = snap.data();
              if (game.state !== "playing") return;

              let newIndex = (game.lyricIndex + 1) % lyrics.length;
              let updates = { lyricIndex: newIndex };

              if (newIndex === outIndex) {
                const playersUpdated = game.players.map(p =>
                  p.id === game.potatoHolder ? { ...p, alive: false } : p
                );
                updates.players = playersUpdated;
                const alivePlayers = playersUpdated.filter(p => p.alive);
                if (alivePlayers.length <= 1) {
                  updates.state = "ended";
                } else {
                  updates.potatoHolder = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
                  updates.lyricIndex = 0;
                }
              }

              transaction.update(gameRef, updates);
            });
          } catch (e) {
            console.error("Lyric transaction failed:", e);
          }
        }, 2000);
      }
    } else if (game.state === "ended") {
      const me = game.players.find(p => p.id === playerId);
      if (me && me.alive) {
        alert("You win!");
      } else {
        alert("Game over");
      }
      await leaveGame();
    }
    roomDisplay.textContent = gameId;
  });
}

function renderPlayers(players, hostId) {
  playerListEl.innerHTML = "";
  players.forEach(p => {
    if (!p.alive) return; // Skip rendering players who are not alive
    const div = document.createElement("div");
    div.className = "player";
    if (p.id === hostId) div.classList.add("host");
    div.textContent = p.name;

    if (p.id === playerId && joined) {
      const leaveBtn = document.createElement("button");
      leaveBtn.textContent = "Leave";
      leaveBtn.style.marginLeft = "8px";
      leaveBtn.onclick = async () => {
        await leaveGame();
      };
      div.appendChild(leaveBtn);
    }

    playerListEl.appendChild(div);
  });
  setStartButton(isHost && players.filter(p => p.alive).length >= 2);
}

function renderDiagram(players, holder) {
  const diagramEl = document.getElementById("playerDiagram");
  diagramEl.innerHTML = "";
  diagramEl.style.position = "relative";
  diagramEl.style.width = "400px";
  diagramEl.style.height = "400px";

  const num = players.length;
  players.forEach((p, i) => {
    const icon = document.createElement("div");
    icon.style.position = "absolute";
    const angle = 2 * Math.PI * i / num;
    icon.style.left = `${200 + 150 * Math.cos(angle)}px`;
    icon.style.top = `${200 + 150 * Math.sin(angle)}px`;
    icon.style.transform = "translate(-50%, -50%)";
    icon.style.textAlign = "center";
    if (!p.alive) icon.style.opacity = "0.5";

    const nameSpan = document.createElement("div");
    nameSpan.textContent = p.name;
    nameSpan.style.fontSize = "12px";
    nameSpan.style.color = "#ffd700";
    icon.appendChild(nameSpan);

    const avatar = document.createElement("div");
    avatar.textContent = p.alive ? "🧑" : "💀";
    if (p.id === holder && p.alive) avatar.textContent += "🥔";
    avatar.style.fontSize = "30px";
    icon.appendChild(avatar);

    diagramEl.appendChild(icon);
  });
}

async function leaveGame() {
  if (!playerId || !gameId) return;
  const gameRef = doc(db, "games", gameId);
  try {
    const snap = await getDoc(gameRef);
    if (!snap.exists()) return;
    const game = snap.data();
    const newPlayers = game.players.filter(p => p.id !== playerId);
    await updateDoc(gameRef, { players: newPlayers });

    if (game.host === playerId && newPlayers.length > 0) {
      await updateDoc(gameRef, { host: newPlayers[0].id });
    }
  } catch (e) {
    console.error(e);
  }
  localStorage.removeItem('playerId');
  localStorage.removeItem('playerName');
  localStorage.removeItem('gameId');
  playerId = null;
  playerName = "";
  gameId = null;
  joined = false;
  joinBtn.style.display = "inline-block";
  leaveBtn.style.display = "none";
  setStartButton(false);
  gameArea.style.display = "none";
  lobbyArea.style.display = "block";
  potatoStatus.textContent = "Waiting for game to start...";
  lyricDisplay.textContent = "";
  clicksDisplay.textContent = "";
  potatoTimerDisplay.textContent = "";
  passBtn.style.display = "none";
  setStatus("");
  stopHoldTimer();
  if (lyricTimer) {
    clearInterval(lyricTimer);
    lyricTimer = null;
  }
  roomDisplay.textContent = "";
}

window.addEventListener('beforeunload', async () => {
  // Don't auto-remove player on reload — keep them in the game
});

function setStartButton(enabled) {
  startBtn.disabled = !enabled;
  startBtn.style.display = isHost ? "inline-block" : "none";
}

</script>

</body>
</html>
